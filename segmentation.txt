int matching_frame_width = 480, matching_frame_height = 360;
int tracking_frame_width = 480, tracking_frame_height = 272;
string comparePath = "/home/pi/Pictures/Template/CountShape2.png";

Mat imageMatch, imageTrack;
Mat imageCompareInput, imageCompare;
Mat imageHSV, imageMask, imageErode, imageDilate;
Mat imgHSVCompare, imageMaskCompare;
Mat transformMatrix, transformImage, imageXOR;
Mat kernelErode, kernelDilate;

//double contour_area;
float compare_output;

Vector <Vector<Point>> contours, contoursCompare;
Vector <Vector<Point>> approx, approxCompare;
Point2f input_coordinate[4], output_coordinate[4];



robot->webcam.read(imageMatch);

imageCompareInput = imread(comparePath);
resize(imageCompareInput, imageCompare, Size(matching_frame_width, matching_frame_height));

char keyRecord = (char) waitKey(1);
if (keyRecord == 'c') {
    imwrite("/home/pi/Pictures/record.png", imageMatch);
    std::cout << "Record success" << std::endl;
}

//trackBarHsvDetection(robot);

kernelErode = getStructuringElement(MORPH_RECT, Size(6, 6));
kernelDilate = getStructuringElement(MORPH_RECT, Size(3, 3));

cvtColor(imageMatch, imageHSV, COLOR_BGR2HSV);
inRange(imageHSV, Scalar(157, 157, 114), Scalar(180, 255, 255), imageMask);

cvtColor(imageCompare, imgHSVCompare, COLOR_BGR2HSV);
inRange(imgHSVCompare, Scalar(64, 0, 0), Scalar(180, 255, 255), imageMaskCompare);

//erode-dilate algorithm
erode(imageMask, imageErode, kernelErode);
dilate(imageErode, imageDilate, kernelDilate);
findContours(imageDilate, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);

//contour_area = contourArea(contours[0]);

/*approx.resize(contours.size());
for (int i = 0; i < contours.size(); i++) {
    approx[i].resize(contours[i].size());
    approxPolyDP(contours[i], approx[i], 5, true);
}
drawContours(imageMatch, Mat(approx[0]), -1, Scalar(0, 255, 0), 8);
//find contours of compared image
findContours(imageMaskCompare, contoursCompare, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);
approxCompare.resize(contoursCompare.size());
for (int i = 0; i < contoursCompare.size(); i++) {
    approxCompare[i].resize(contoursCompare[i].size());
    approxPolyDP(contoursCompare[i], approxCompare[i], 5, true);
}
drawContours(imageCompare, Mat(approxCompare[0]), -1, Scalar(0, 255, 0), 8);
for (int j = 0; j < 4; j++) {
    input_coordinate[j] = approx[0][j];
    output_coordinate[j] = approxCompare[0][j];
}
transformMatrix = getPerspectiveTransform(input_coordinate, output_coordinate);
warpPerspective(imageDilate, transformImage, transformMatrix, Size(imageDilate.cols, imageDilate.rows));
//XOR
bitwise_xor(transformImage, imageMaskCompare, imageXOR);
compare_output = 100.0f * (1 - (float) countNonZero(imageXOR) / (float) (imageXOR.cols * imageXOR.rows));*/

//modeCheck(robot);

//setMouseCallback("origin", RGBCallback, &imageMatch);
//setMouseCallback("origin", HSVCallback, &imageHSV);

//std::cout << compare_output << std::endl;

//imshow("erode", imageErode);
imshow("origin", imageMatch);
//imshow("mask", imageMask);
//imshow("transform", transformImage);
//imshow("compareMask", imageMaskCompare);
//imshow("XOR", imageXOR);

waitKey(1);